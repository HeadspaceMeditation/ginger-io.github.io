---
layout: post
title: "Introducing Jay-Z"
date: 2020-04-09
categories: [security, aws]
---

## Ginger’s TypeScript library for application-layer encryption

As engineers we have a moral responsibility to protect the sensitive data we store. And that can be a lot of responsibility since mass data leaks are a [huge problem](https://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/).

We're a (mental) healthcare company that stores clinical data. So we care deeply about this. And that's why we're excited to give you a sneak preview of our new open source library: **[Jay-Z](https://github.com/ginger-io/jay-z)**.

> With Jay-Z you’ve 99 security problems. But application-layer encryption ain’t one :-)!

Jay-Z is a TypeScript library that makes application-layer encryption super easy. It's built with [libsodium](https://libsodium.gitbook.io/doc/) and supports [AWS KMS](https://aws.amazon.com/kms/) out of the box. It's primarily intended for use with “noSQL” data stores, like [DynamoDB](https://aws.amazon.com/dynamodb/), but it can be used for other purposes as well (e.g. storing data in S3).

## What’s application-level encryption? Why is it important?

AWS offers an encryption-at-rest feature for DynamoDB, RDS and S3. This is good. You should turn it on.

But it’s not sufficient protection for your more sensitive data.

The problem is that these features encrypt data _after_ it arrives at the AWS service and decrypt it _before_ sending an API response. This results in anybody with AWS console (or API) access to that service being able to view all your data in plaintext.

Of course, you can lock down these permissions via IAM. But somebody is almost certainly going to wind up with `*` permissions that were only supposed to be “temporary” - e.g. somebody had to fix a bug in production and forgot to release their creds.

It’s much safer to encrypt and decrypt data at the application layer, using keys the storage layer doesn’t have access to. This ensures that you need both IAM permission to the service and access to the encryption key(s).

This is what Jay-Z does.

## How does Jay-Z work?

Jay-Z encrypts and decrypts JSON objects. And its API is quite simple just `encryptItem` and `decryptItem`.

### EncryptItem

When you call `encryptItem`, you specify a set of fields to encrypt and the others are left as plaintext (e.g. if persisting to DynamoDB, you don't want to encrypt your object's primary key, sort key or indexed attributes).

By default, Jay-Z encrypts the specified fields of your JSON object with a unique data key. This key is generated by a configured `DataKeyProvider` class. AWS KMS is intended to be the “default” key provider (Jay-Z ships with a `KMSDataKeyProvider`), but you can roll your own too.

When a `DataKeyProvider` generates a data key, it returns two versions of that key - one encrypted (e.g. using a KMS Master Key), and one plaintext.

The plaintext key is used to encrypt each specified field of your JSON item using libsodium’s [secretbox](https://libsodium.gitbook.io/doc/secret-key_cryptography/secretbox). And the encrypted data key, nonce and other metadata required for decryption are appended to your JSON item in a `__jayz__metadata` field.

### DecryptItem

When you call decryptItem Jay-Z looks for a `__jayz__metadata` field on your item, asks the `DataKeyProvider` to decrypt the data key. And then uses the (now) plaintext data key to decrypt each field in your JSON item.

### Diagram

Let’s look at a diagram of this flow ([full size](https://github.com/ginger-io/jay-z/raw/master/diagram.svg?sanitize=true)):

<img src="https://github.com/ginger-io/jay-z/raw/master/diagram.svg?sanitize=true" />

## What does Jay-Z’s API look like?

Now that we’ve covered how Jay-Z works, let's take a look at how to use it. For illustrative purposes, assume we want to use AWS KMS and the included `KMSDataKeyProvider`.

### 1. Get yourself a Jay-Z

The first thing you need to do is get a JayZ object:

```typescript
import { KMS } from "aws-sdk";
import { KMSDataKeyProvider, JayZ } from "@ginger.io/jay-z";

const kmsKeyId = "..."; // the KMS key id or arn you want to use
const keyProvider = new KMSDataKeyProvider(kmsKeyId, new KMS());
const jayZ = new JayZ({ keyProvider });
```

### 2. Encrypt a bank account

Then we can start encrypting JSON objects, like a `BankAccount`:

```typescript
const bankAccount: BankAccount = {
  id: "1",
  accountNumber: "an-123",
  routingNumber: "rn-123",
};

const encryptedItem = await jayZ.encryptItem(
  bankAccount,
  ["accountNumber", "routingNumber"] // fields to encrypt
);
```

#### Note

Jay-Z does not suffer foolish mistakes (like typos).

Thus the TypeScript type for `encryptedItem` (above) is correctly inferred. The `accountNumber` and `routingNumber` fields are now (encrypted) binary data and thus have a type of `UInt8Array`. The id field will be untouched and still be a `string`. And the `__jayz__metadata` field will be present in the return type as well.

So when you serialize your data to your data store, you can rest assured that you properly process all of the necessary fields.

### 3. Decrypt a bank account

Finally, decryption with Jay-Z is easy, just 1 line:

```typescript
const decryptedItem = await jayZ.decryptItem(encrypted);
```

## Providing your own DataKeyProvider

If you don’t want to use KMS (or can’t because you’re not on AWS), you can provide your own. Just implement the DataKeyProvider interface, which is quite simple:

```typescript
export interface DataKeyProvider {
  generateDataKey(): Promise<DataKey>;
  decryptDataKey(encryptedDataKey: Uint8Array): Promise<Uint8Array>;
}

export type DataKey = {
  dataKey: Uint8Array;
  encryptedDataKey: Uint8Array;
};
```

Once you have your CustomKeyProvider, you can plug it into Jay-Z like so:

```typescript
const keyProvider = new CustomDataKeyProvider(...)
const jayZ = new JayZ({ keyProvider })
```

## Providing your own Encryptor

Recall that Jay-Z uses libsodium’s secretbox to handle the underlying encryption and decryption operations. Given libsodium is one of the most often recommended libraries by cryptographers - you should just use this if you can.

But if for some reason you need to use a different encryption or decryption strategy, you can implement the Encryptor interface:

```typescript
export interface Encryptor {
  readonly scheme: EncryptionScheme;

  encrypt<T, K extends keyof T>(
    params: EncryptParams<T, K>
  ): Promise<EncryptResult<T, K>>;

  decrypt<T, K extends keyof T>(
    params: DecryptParams<T, K>
  ): Promise<DecryptResult<T>>;
}

export type EncryptParams<T, K extends keyof T> = {
  item: T;
  fieldsToEncrypt: K[];
  dataKey: Uint8Array;
};

export type EncryptResult<T, K extends keyof T> = {
  encryptedItem: ItemWithEncryptedFields<T, K>;
  nonce: Uint8Array;
};

export type DecryptParams<T, K extends keyof T> = {
  encryptedItem: ItemWithEncryptedFields<T, K>;
  fieldsToDecrypt: K[];
  dataKey: Uint8Array;
  nonce: Uint8Array;
};

export type DecryptResult<T> = {
  decryptedItem: T;
};
```

And once we have our CustomEncryptor, we can plug it in like so:

```typescript
const keyProvider = new CustomDataKeyProvider(...)
const encryptor = new CustomEncryptor(...)
const jayZ = new JayZ({ keyProvider, encryptor })
```

## Amortizing write latency and costs

Recall that by default Jay-Z requests a fresh data key from the configured DataKeyProvider on every encryption. This is the most secure option, which is why it is the default.

But for some high-write use-cases, you might wish to trade security in order to reduce network latency and/or billing costs. KMS is both fairly fast and fairly cheap, but you might not be using KMS.

So Jay-Z allows you to amortize these costs by reusing data keys across encryption operations via its maxUsesPerDataKey parameter.

Setting this to a value of N means that Jay-Z will reuse a particular data key a maximum of N times before requesting a new one. For example we could set this to 100:

```typescript
const keyProvider = new KMSDataKeyProvider(kmsKeyId, new KMS());
const jayZ = new JayZ({ keyProvider, maxUsesPerDataKey: 100 });
```

If you choose to use this option, just be aware of the security tradeoffs you’re making.

## Use cases for Jay-Z

### DynamoDB or other “NoSQL” databases

Jay-Z was originally designed with DynamoDB in mind. Thus it is a natural fit to use here. You can use Jay-Z as a standalone library but we have an upcoming blog-post that you’ll want to stay-tuned for (hint, it involves another library we’re calling Beyoncé).

### S3

If you’re storing JSON documents in S3 - or you store your data in S3 in another format, but your domain objects are JSON or JSON-like - Jay-Z might be a good fit for you. However if you’re using a binary format - Jay-Z isn’t going to be a great fit for your use-case.

### SQL-ORMs

Jay-Z could potentially be used as “middleware” to a SQL-like ORM whose domain objects are either JSON or JS/TypeScript classes. But it’s important to point out that this is much less of a natural fit than with “NoSQL” datastores as the middleware would have to implement a strategy to persist the `__jayz__metadata` field and rehydrate it into domain objects - e.g. either as a column on each “model” or in a special table.

## Future work

There’s a few things that would improve Jay-Z that we’re currently thinking about. No promises as to our road-map, but here’s what’s on our minds:

### Custom signatures

Jay-Z’s default encryption strategy uses authenticated encryption. But for some use-cases you might want to calculate a custom signature (e.g. HMAC) that includes additional data that you care about.

Jay-Z could easily support this by giving callers a way to plug-in a custom signature, which could be appended to the `__jayz__metadata` field. And verified prior to attempting to decrypt an item.

### An optional feature to amortize read latency and/or billing costs

Jay-Z currently offers a way to amortize write latency and/or billing costs via a parameter that lets you specify how many times a data key can be used. It’d be nice to offer a way to amortize read latency and/or billing costs as well.

This could be accomplished by introducing a data-key cache at the application layer. This of course reduces the level of security offered. And at the time of writing appears to be a fairly niche use-case, so it has not yet been implemented in Jay-Z.
