<!DOCTYPE html>
<html>
  <head>
    <link
      rel="stylesheet"
      href="https://fonts.googleapis.com/css?family=Merriweather:300,300italic,400,400italic,700,700italic,900,900italic%7COpen+Sans:300,300italic,400,400italic,600,600italic,700,700italic,800,800italic"
      media="all"
    />

    <link rel="stylesheet" href="/assets/css/bulma.min.css" media="all" />
    <link rel="stylesheet" href="/assets/css/main.css" media="all" />
  </head>
  <body>
      <nav class="mainNav">
        <img src="/assets/images/logo.svg" />
      </nav>

    </div>
    <div class="container content">
      <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Introducing Jay-Z</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-04-09T00:00:00-07:00" itemprop="datePublished">Apr 9, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <h2 id="gingers-typescript-library-for-application-layer-encryption">Ginger’s TypeScript library for application-layer encryption</h2>

<p>As engineers we have a moral responsibility to protect the sensitive data we store. And that can be a lot of responsibility since mass data leaks are a <a href="https://www.informationisbeautiful.net/visualizations/worlds-biggest-data-breaches-hacks/">huge problem</a>.</p>

<p>We’re a (mental) healthcare company that stores clinical data. So we care deeply about this. And that’s why we’re excited to give you a sneak preview of our new open source library: <strong><a href="https://github.com/ginger-io/jay-z">Jay-Z</a></strong>.</p>

<blockquote>
  <p>With Jay-Z you’ve 99 security problems. But application-layer encryption ain’t one :-)!</p>
</blockquote>

<p>Jay-Z is a TypeScript library that makes application-layer encryption super easy. It’s built with <a href="https://libsodium.gitbook.io/doc/">libsodium</a> and supports <a href="https://aws.amazon.com/kms/">AWS KMS</a> out of the box. It’s primarily intended for use with “noSQL” data stores, like <a href="https://aws.amazon.com/dynamodb/">DynamoDB</a>, but it can be used for other purposes as well (e.g. storing data in S3).</p>

<h2 id="whats-application-level-encryption-why-is-it-important">What’s application-level encryption? Why is it important?</h2>

<p>AWS offers an encryption-at-rest feature for DynamoDB, RDS and S3. This is good. You should turn it on.</p>

<p>But it’s not sufficient protection for your more sensitive data.</p>

<p>The problem is that these features encrypt data <em>after</em> it arrives at the AWS service and decrypt it <em>before</em> sending an API response. This results in anybody with AWS console (or API) access to that service being able to view all your data in plaintext.</p>

<p>Of course, you can lock down these permissions via IAM. But somebody is almost certainly going to wind up with <code class="highlighter-rouge">*</code> permissions that were only supposed to be “temporary” - e.g. somebody had to fix a bug in production and forgot to release their creds.</p>

<p>It’s much safer to encrypt and decrypt data at the application layer, using keys the storage layer doesn’t have access to. This ensures that you need both IAM permission to the service and access to the encryption key(s).</p>

<p>This is what Jay-Z does.</p>

<h2 id="how-does-jay-z-work">How does Jay-Z work?</h2>

<p>Jay-Z encrypts and decrypts JSON objects. And its API is quite simple just <code class="highlighter-rouge">encryptItem</code> and <code class="highlighter-rouge">decryptItem</code>.</p>

<h3 id="encryptitem">EncryptItem</h3>

<p>When you call <code class="highlighter-rouge">encryptItem</code>, you specify a set of fields to encrypt and the others are left as plaintext (e.g. if persisting to DynamoDB, you don’t want to encrypt your object’s primary key, sort key or indexed attributes).</p>

<p>By default, Jay-Z encrypts the specified fields of your JSON object with a unique data key. This key is generated by a configured <code class="highlighter-rouge">DataKeyProvider</code> class. AWS KMS is intended to be the “default” key provider (Jay-Z ships with a <code class="highlighter-rouge">KMSDataKeyProvider</code>), but you can roll your own too.</p>

<p>When a <code class="highlighter-rouge">DataKeyProvider</code> generates a data key, it returns two versions of that key - one encrypted (e.g. using a KMS Master Key), and one plaintext.</p>

<p>The plaintext key is used to encrypt each specified field of your JSON item using libsodium’s <a href="https://libsodium.gitbook.io/doc/secret-key_cryptography/secretbox">secretbox</a>. And the encrypted data key, nonce and other metadata required for decryption are appended to your JSON item in a <code class="highlighter-rouge">__jayz__metadata</code> field.</p>

<h3 id="decryptitem">DecryptItem</h3>

<p>When you call decryptItem Jay-Z looks for a <code class="highlighter-rouge">__jayz__metadata</code> field on your item, asks the <code class="highlighter-rouge">DataKeyProvider</code> to decrypt the data key. And then uses the (now) plaintext data key to decrypt each field in your JSON item.</p>

<h3 id="diagram">Diagram</h3>

<p>Let’s look at a diagram of this flow (<a href="https://github.com/ginger-io/jay-z/raw/master/diagram.svg?sanitize=true">full size</a>):</p>

<p><img src="https://github.com/ginger-io/jay-z/raw/master/diagram.svg?sanitize=true" /></p>

<h2 id="what-does-jay-zs-api-look-like">What does Jay-Z’s API look like?</h2>

<p>Now that we’ve covered how Jay-Z works, let’s take a look at how to use it. For illustrative purposes, assume we want to use AWS KMS and the included <code class="highlighter-rouge">KMSDataKeyProvider</code>.</p>

<h3 id="1-get-yourself-a-jay-z">1. Get yourself a Jay-Z</h3>

<p>The first thing you need to do is get a JayZ object:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">import</span> <span class="p">{</span> <span class="nx">KMS</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">aws-sdk</span><span class="dl">"</span><span class="p">;</span>
<span class="k">import</span> <span class="p">{</span> <span class="nx">KMSDataKeyProvider</span><span class="p">,</span> <span class="nx">JayZ</span> <span class="p">}</span> <span class="k">from</span> <span class="dl">"</span><span class="s2">@ginger.io/jay-z</span><span class="dl">"</span><span class="p">;</span>

<span class="kd">const</span> <span class="nx">kmsKeyId</span> <span class="o">=</span> <span class="dl">"</span><span class="s2">...</span><span class="dl">"</span><span class="p">;</span> <span class="c1">// the KMS key id or arn you want to use</span>
<span class="kd">const</span> <span class="nx">keyProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">KMSDataKeyProvider</span><span class="p">(</span><span class="nx">kmsKeyId</span><span class="p">,</span> <span class="k">new</span> <span class="nx">KMS</span><span class="p">());</span>
<span class="kd">const</span> <span class="nx">jayZ</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JayZ</span><span class="p">({</span> <span class="nx">keyProvider</span> <span class="p">});</span>
</code></pre></div></div>

<h3 id="2-encrypt-a-bank-account">2. Encrypt a bank account</h3>

<p>Then we can start encrypting JSON objects, like a <code class="highlighter-rouge">BankAccount</code>:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">bankAccount</span><span class="p">:</span> <span class="nx">BankAccount</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">id</span><span class="p">:</span> <span class="dl">"</span><span class="s2">1</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">accountNumber</span><span class="p">:</span> <span class="dl">"</span><span class="s2">an-123</span><span class="dl">"</span><span class="p">,</span>
  <span class="na">routingNumber</span><span class="p">:</span> <span class="dl">"</span><span class="s2">rn-123</span><span class="dl">"</span><span class="p">,</span>
<span class="p">};</span>

<span class="kd">const</span> <span class="nx">encryptedItem</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">jayZ</span><span class="p">.</span><span class="nx">encryptItem</span><span class="p">(</span>
  <span class="nx">bankAccount</span><span class="p">,</span>
  <span class="p">[</span><span class="dl">"</span><span class="s2">accountNumber</span><span class="dl">"</span><span class="p">,</span> <span class="dl">"</span><span class="s2">routingNumber</span><span class="dl">"</span><span class="p">]</span> <span class="c1">// fields to encrypt</span>
<span class="p">);</span>
</code></pre></div></div>

<h4 id="note">Note</h4>

<p>Jay-Z does not suffer foolish mistakes (like typos).</p>

<p>Thus the TypeScript type for <code class="highlighter-rouge">encryptedItem</code> (above) is correctly inferred. The <code class="highlighter-rouge">accountNumber</code> and <code class="highlighter-rouge">routingNumber</code> fields are now (encrypted) binary data and thus have a type of <code class="highlighter-rouge">UInt8Array</code>. The id field will be untouched and still be a <code class="highlighter-rouge">string</code>. And the <code class="highlighter-rouge">__jayz__metadata</code> field will be present in the return type as well.</p>

<p>So when you serialize your data to your data store, you can rest assured that you properly process all of the necessary fields.</p>

<h3 id="3-decrypt-a-bank-account">3. Decrypt a bank account</h3>

<p>Finally, decryption with Jay-Z is easy, just 1 line:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">decryptedItem</span> <span class="o">=</span> <span class="k">await</span> <span class="nx">jayZ</span><span class="p">.</span><span class="nx">decryptItem</span><span class="p">(</span><span class="nx">encrypted</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="providing-your-own-datakeyprovider">Providing your own DataKeyProvider</h2>

<p>If you don’t want to use KMS (or can’t because you’re not on AWS), you can provide your own. Just implement the DataKeyProvider interface, which is quite simple:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kr">interface</span> <span class="nx">DataKeyProvider</span> <span class="p">{</span>
  <span class="nx">generateDataKey</span><span class="p">():</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">DataKey</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="nx">decryptDataKey</span><span class="p">(</span><span class="nx">encryptedDataKey</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nb">Uint8Array</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">DataKey</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">dataKey</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
  <span class="nl">encryptedDataKey</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>Once you have your CustomKeyProvider, you can plug it into Jay-Z like so:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">keyProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CustomDataKeyProvider</span><span class="p">(...)</span>
<span class="kd">const</span> <span class="nx">jayZ</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JayZ</span><span class="p">({</span> <span class="nx">keyProvider</span> <span class="p">})</span>
</code></pre></div></div>

<h2 id="providing-your-own-encryptor">Providing your own Encryptor</h2>

<p>Recall that Jay-Z uses libsodium’s secretbox to handle the underlying encryption and decryption operations. Given libsodium is one of the most often recommended libraries by cryptographers - you should just use this if you can.</p>

<p>But if for some reason you need to use a different encryption or decryption strategy, you can implement the Encryptor interface:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">export</span> <span class="kr">interface</span> <span class="nx">Encryptor</span> <span class="p">{</span>
  <span class="nx">readonly</span> <span class="nx">scheme</span><span class="p">:</span> <span class="nx">EncryptionScheme</span><span class="p">;</span>

  <span class="nx">encrypt</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">params</span><span class="p">:</span> <span class="nx">EncryptParams</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;</span>
  <span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">EncryptResult</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;&gt;</span><span class="p">;</span>

  <span class="nx">decrypt</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span><span class="p">(</span>
    <span class="nx">params</span><span class="p">:</span> <span class="nx">DecryptParams</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;</span>
  <span class="p">):</span> <span class="nb">Promise</span><span class="o">&lt;</span><span class="nx">DecryptResult</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">EncryptParams</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">item</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
  <span class="nl">fieldsToEncrypt</span><span class="p">:</span> <span class="nx">K</span><span class="p">[];</span>
  <span class="nl">dataKey</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">EncryptResult</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">encryptedItem</span><span class="p">:</span> <span class="nx">ItemWithEncryptedFields</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="nl">nonce</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">DecryptParams</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span> <span class="kd">extends</span> <span class="nx">keyof</span> <span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">encryptedItem</span><span class="p">:</span> <span class="nx">ItemWithEncryptedFields</span><span class="o">&lt;</span><span class="nx">T</span><span class="p">,</span> <span class="nx">K</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="nl">fieldsToDecrypt</span><span class="p">:</span> <span class="nx">K</span><span class="p">[];</span>
  <span class="nl">dataKey</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
  <span class="nl">nonce</span><span class="p">:</span> <span class="nb">Uint8Array</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">export</span> <span class="nx">type</span> <span class="nx">DecryptResult</span><span class="o">&lt;</span><span class="nx">T</span><span class="o">&gt;</span> <span class="o">=</span> <span class="p">{</span>
  <span class="na">decryptedItem</span><span class="p">:</span> <span class="nx">T</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>And once we have our CustomEncryptor, we can plug it in like so:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">keyProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CustomDataKeyProvider</span><span class="p">(...)</span>
<span class="kd">const</span> <span class="nx">encryptor</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">CustomEncryptor</span><span class="p">(...)</span>
<span class="kd">const</span> <span class="nx">jayZ</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JayZ</span><span class="p">({</span> <span class="nx">keyProvider</span><span class="p">,</span> <span class="nx">encryptor</span> <span class="p">})</span>
</code></pre></div></div>

<h2 id="amortizing-write-latency-and-costs">Amortizing write latency and costs</h2>

<p>Recall that by default Jay-Z requests a fresh data key from the configured DataKeyProvider on every encryption. This is the most secure option, which is why it is the default.</p>

<p>But for some high-write use-cases, you might wish to trade security in order to reduce network latency and/or billing costs. KMS is both fairly fast and fairly cheap, but you might not be using KMS.</p>

<p>So Jay-Z allows you to amortize these costs by reusing data keys across encryption operations via its maxUsesPerDataKey parameter.</p>

<p>Setting this to a value of N means that Jay-Z will reuse a particular data key a maximum of N times before requesting a new one. For example we could set this to 100:</p>

<div class="language-typescript highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">const</span> <span class="nx">keyProvider</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">KMSDataKeyProvider</span><span class="p">(</span><span class="nx">kmsKeyId</span><span class="p">,</span> <span class="k">new</span> <span class="nx">KMS</span><span class="p">());</span>
<span class="kd">const</span> <span class="nx">jayZ</span> <span class="o">=</span> <span class="k">new</span> <span class="nx">JayZ</span><span class="p">({</span> <span class="nx">keyProvider</span><span class="p">,</span> <span class="na">maxUsesPerDataKey</span><span class="p">:</span> <span class="mi">100</span> <span class="p">});</span>
</code></pre></div></div>

<p>If you choose to use this option, just be aware of the security tradeoffs you’re making.</p>

<h2 id="use-cases-for-jay-z">Use cases for Jay-Z</h2>

<h3 id="dynamodb-or-other-nosql-databases">DynamoDB or other “NoSQL” databases</h3>

<p>Jay-Z was originally designed with DynamoDB in mind. Thus it is a natural fit to use here. You can use Jay-Z as a standalone library but we have an upcoming blog-post that you’ll want to stay-tuned for (hint, it involves another library we’re calling Beyoncé).</p>

<h3 id="s3">S3</h3>

<p>If you’re storing JSON documents in S3 - or you store your data in S3 in another format, but your domain objects are JSON or JSON-like - Jay-Z might be a good fit for you. However if you’re using a binary format - Jay-Z isn’t going to be a great fit for your use-case.</p>

<h3 id="sql-orms">SQL-ORMs</h3>

<p>Jay-Z could potentially be used as “middleware” to a SQL-like ORM whose domain objects are either JSON or JS/TypeScript classes. But it’s important to point out that this is much less of a natural fit than with “NoSQL” datastores as the middleware would have to implement a strategy to persist the <code class="highlighter-rouge">__jayz__metadata</code> field and rehydrate it into domain objects - e.g. either as a column on each “model” or in a special table.</p>

<h2 id="future-work">Future work</h2>

<p>There’s a few things that would improve Jay-Z that we’re currently thinking about. No promises as to our road-map, but here’s what’s on our minds:</p>

<h3 id="custom-signatures">Custom signatures</h3>

<p>Jay-Z’s default encryption strategy uses authenticated encryption. But for some use-cases you might want to calculate a custom signature (e.g. HMAC) that includes additional data that you care about.</p>

<p>Jay-Z could easily support this by giving callers a way to plug-in a custom signature, which could be appended to the <code class="highlighter-rouge">__jayz__metadata</code> field. And verified prior to attempting to decrypt an item.</p>

<h3 id="an-optional-feature-to-amortize-read-latency-andor-billing-costs">An optional feature to amortize read latency and/or billing costs</h3>

<p>Jay-Z currently offers a way to amortize write latency and/or billing costs via a parameter that lets you specify how many times a data key can be used. It’d be nice to offer a way to amortize read latency and/or billing costs as well.</p>

<p>This could be accomplished by introducing a data-key cache at the application layer. This of course reduces the level of security offered. And at the time of writing appears to be a fairly niche use-case, so it has not yet been implemented in Jay-Z.</p>

  </div><a class="u-url" href="/security/aws/2020/04/09/introducing-jay-z.html" hidden></a>
</article>

    </div>
  </body>
</html>
